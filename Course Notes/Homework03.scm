#lang racket

;; Third Homework Set
;; CSc 335
;; Spring 2024

;; 1. Exercise 1.9 from A&S, with additional requirements
;; consider two procedures for adding two positive integers

(define (my-plus-version-1 a b)
  (if (= a 0)
      b
      (inc (my-plus-version-1 (dec a) b))))
;; Adds b to the how far a is away from 0. The distance of a from 0 becomes the amount of
;; recursive steps it takes to get to (= a 0) b. For example, if a=2, b=2,
;; it will take two steps to get to a=0 (two calls of dec), and then once a=0, we return b
;; and the recursive function returns inc () of the b returned and keeps incrementing
;; for the amount of steps taken
(define (my-plus-version-2 a b)
  (if (= a 0)
      b
      (my-plus-version-2 (dec a) (inc b))))
;; This version basically increments b until a reaches 0, theoretically adding b to a
;; then we return b, which is a+b where a becomes 0 but b increments till a is 0
;; where

(define (inc x) (+ x 1))

(define (dec x) (- x 1))

;; Using the substitution model, illustrate the process generated by each
;; procedure in evaluating (my-plus 4 5). Are the processes recursive or
;; iterative?

;; my-plus-version-1

;; (my-plus-version-1 4 5)
;; (inc (my-plus-version-1 (3) 5))
;; (inc (inc (my-plus-version-1 (2) 5)))
;; (inc (inc (inc (my-plus-version-1 (1) 5))))
;; (inc (inc (inc (inc (my-plus-version-1 (0) 5))))) -> (inc (inc (inc (inc (5)))))
;; (inc (inc (inc (+ 5 1)))) -> (inc (inc (inc (6))))
;; (inc (inc (+ 6 1))) -> (inc (inc (7)))
;; (inc (+ 7 1)) -> (inc (8))
;; (+ 8 1) -> (9)

;; (my-plus-version-1 2 2)
;; (inc (my-plus-version-1 1 2))
;; (inc (inc (my-plus-version-1 0 2))) -> (inc (inc (2)))
;; (inc (+ 2 1)) -> (inc (3))
;; (+ 3 1) -> (4)

; the above my-plus-version is recursive

;; my-plus-version-2

;; (my-plus-version-2 4 5)
;; (my-plus-version-2 3 6)
;; (my-plus-version-2 2 7)
;; (my-plus-version-2 1 8)
;; (my-plus-version-2 0 9)
;; 9

; the above my-plus-version is iterative/tail-recursive

;; Certify each procedure, using the appropriate technique, as determined
;; by your answer to the classification question above: for the recursive
;; procedure, give a proof based on the size of (one of) the arguments; for
;; the iterative procedure, give a proof which uses an invariant (which you
;; must first discover)


;; 2. Develop and certify iterative and recursive scheme functions to return the sum of the
;; digits within a non-negative integer.  For example, (sum-of-digits 345) is 12.
(define sum-of-digits
  (lambda (x)
    (cond
      ((zero? (floor (/ x 10))) x)
      (else
       (+ (modulo x 10) (sum-of-digits (floor (/ x 10)))))
       )))


(sum-of-digits 34)


